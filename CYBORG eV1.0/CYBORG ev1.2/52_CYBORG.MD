

# **ðŸ“˜ PAGE 10.7 â€” C LAYER CONTROLâ€‘FLOW RULES (FORMAL)**  
### *AVIS Cyborg Language System â€” MSDN + ISO Hybrid Reference*  
*(Hybrid Markdown + Codeâ€‘Styled Blocks Edition)*  

---

## **10.7 Overview**

The **Controlâ€‘Flow Rules** define what the generated C function may and may not do with respect to:

- branching  
- looping  
- conditional logic  
- early termination  
- flow manipulation  

The C Layer is not a program.  
It is a **mechanical execution schedule** derived from IR.  
Its control flow must be **perfectly linear**.

This section is **normative**.

---

# **10.7.1 Control Rule 1 â€” No Branching**

The C Layer MUST NOT contain:

- `if`  
- `else`  
- `switch`  
- `case`  
- conditional operators (`?:`)  

### **Meaning**  
Execution is **branchless**.

---

# **10.7.2 Control Rule 2 â€” No Loops**

The C Layer MUST NOT contain:

- `for`  
- `while`  
- `do`  
- recursion  
- iteration of any kind  

### **Meaning**  
Execution is **nonâ€‘iterative**.

---

# **10.7.3 Control Rule 3 â€” No Early Returns**

The C Layer MUST NOT:

- return early  
- exit based on a verb result  
- shortâ€‘circuit the OR chain  

### **Forbidden**
```c
if (r1) return r1;   // forbidden
```

### **Meaning**  
All verbs MUST run.

---

# **10.7.4 Control Rule 4 â€” No Goto or Jumps**

The C Layer MUST NOT contain:

- `goto`  
- labels  
- jumps  
- computed jumps  

### **Meaning**  
Execution is **strictly sequential**.

---

# **10.7.5 Control Rule 5 â€” No Exception Handling**

The C Layer MUST NOT contain:

- `try`  
- `catch`  
- `throw`  
- `longjmp`  
- `setjmp`  

### **Meaning**  
Execution is **nonâ€‘exceptional**.

---

# **10.7.6 Control Rule 6 â€” No Conditional Compilation**

The C Layer MUST NOT contain:

- `#ifdef`  
- `#ifndef`  
- `#if`  
- `#elif`  
- `#endif`  

### **Meaning**  
The payload is **platformâ€‘invariant**.

---

# **10.7.7 Control Rule 7 â€” No Conditional Verb Invocation**

The C Layer MUST NOT:

- call verbs based on conditions  
- skip verbs based on context  
- reorder verbs based on logic  

### **Meaning**  
Verb invocation is **literal**.

---

# **10.7.8 Control Rule 8 â€” No Flowâ€‘Dependent Behavior**

The C Layer MUST NOT:

- compute flags  
- track state  
- branch on memory  
- branch on context  
- branch on verb results  

### **Meaning**  
Control flow is **static**.

---

# **10.7.9 Control Rule 9 â€” Only One Controlâ€‘Flow Construct Allowed**

The only allowed controlâ€‘flow construct is:

```
return (r1 || r2 || ... || rn);
```

This is the **sole** controlâ€‘flow operation in the entire function.

### **Meaning**  
The payload ends with a **single deterministic verdict**.

---

# **10.7.10 Control Rule 10 â€” Control Flow Must Be Deterministic**

Given the same IR:

- the same control flow MUST be generated  
- on all platforms  
- with all compilers  
- with all optimization levels  

### **Meaning**  
Control flow is **mathematically reproducible**.

---

# **10.7.11 Canonical Example â€” Mixed Verbs**

### **IR**
```
TARGET = FILE
OPEN_PAYLOAD
EXEC_SCAN
EXEC_BUILD
EXEC_EXPLAIN
SEAL
```

### **Generated C**
```c
int cyborg_payload(CyborgFile* ctx) {
    int r1 = scan_context(ctx);
    int r2 = build_context(ctx);
    int r3 = explain_context(ctx);
    return (r1 || r2 || r3);
}
```

### **Controlâ€‘Flow Interpretation**
- no branches  
- no loops  
- no early returns  
- no conditions  
- no jumps  
- single final return  

This is the **canonical controlâ€‘flow pattern**.

---

# **10.7.12 Summary**

Page 10.7 defines the **C Layer Controlâ€‘Flow Rules**:

- no branching  
- no loops  
- no early returns  
- no jumps  
- no exceptions  
- no conditional compilation  
- no conditional invocation  
- no flowâ€‘dependent behavior  
- only one final return  
- deterministic control flow  

The C Layer is **perfectly linear**, **perfectly literal**, and **perfectly deterministic**.
